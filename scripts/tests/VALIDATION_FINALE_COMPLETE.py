#!/usr/bin/env python3
"""
VALIDATION FINALE COMPL√àTE - ALX PROJECT NEXUS
Test exhaustif avec gestion d'erreurs robuste
"""

import requests
import json
import sys
import time
from datetime import datetime
import traceback

class ComprehensiveValidator:
    """Validateur complet avec gestion d'erreurs robuste"""
    
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.graphql_url = f"{base_url}/graphql/"
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'ALX-Project-Nexus-Validator/1.0'
        })
        
        # Statistiques
        self.total_tests = 0
        self.passed_tests = 0
        self.failed_tests = 0
        self.errors = []
        self.warnings = []
        
        # Configuration des timeouts
        self.timeout = 30
        
    def log_success(self, message):
        """Log un succ√®s"""
        print(f"‚úÖ {message}")
        self.passed_tests += 1
    
    def log_error(self, message, error=None):
        """Log une erreur"""
        print(f"‚ùå {message}")
        if error:
            print(f"   D√©tail: {str(error)}")
            self.errors.append(f"{message}: {str(error)}")
        else:
            self.errors.append(message)
        self.failed_tests += 1
    
    def log_warning(self, message):
        """Log un avertissement"""
        print(f"‚ö†Ô∏è {message}")
        self.warnings.append(message)
    
    def safe_request(self, method, url, **kwargs):
        """Effectue une requ√™te s√©curis√©e avec gestion d'erreurs"""
        
        kwargs.setdefault('timeout', self.timeout)
        
        try:
            response = self.session.request(method, url, **kwargs)
            return response, None
        
        except requests.exceptions.ConnectionError as e:
            return None, f"Connection error: {str(e)}"
        
        except requests.exceptions.Timeout as e:
            return None, f"Timeout error: {str(e)}"
        
        except requests.exceptions.RequestException as e:
            return None, f"Request error: {str(e)}"
        
        except Exception as e:
            return None, f"Unexpected error: {str(e)}"
    
    def test_server_connectivity(self):
        """Test la connectivit√© du serveur"""
        
        print("\nüîå TEST DE CONNECTIVIT√â SERVEUR")
        print("-" * 50)
        
        self.total_tests += 1
        
        response, error = self.safe_request('GET', self.base_url)
        
        if error:
            self.log_error("Serveur inaccessible", error)
            return False
        
        if response.status_code == 200:
            self.log_success("Serveur accessible")
            return True
        else:
            self.log_error(f"Serveur r√©pond avec code {response.status_code}")
            return False
    
    def test_graphql_endpoint(self):
        """Test l'endpoint GraphQL"""
        
        print("\nüéØ TEST ENDPOINT GRAPHQL")
        print("-" * 50)
        
        # Test d'introspection
        self.total_tests += 1
        
        introspection_query = {
            "query": """
            query IntrospectionQuery {
              __schema {
                queryType { name }
                mutationType { name }
                types {
                  name
                  kind
                }
              }
            }
            """
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=introspection_query)
        
        if error:
            self.log_error("GraphQL endpoint inaccessible", error)
            return False
        
        if response.status_code != 200:
            self.log_error(f"GraphQL endpoint erreur {response.status_code}")
            return False
        
        try:
            data = response.json()
            
            if 'errors' in data:
                self.log_error("Erreurs GraphQL", data['errors'])
                return False
            
            if 'data' in data and '__schema' in data['data']:
                schema = data['data']['__schema']
                
                # V√©rifier les types de base
                if schema.get('queryType', {}).get('name') == 'Query':
                    self.log_success("Type Query d√©tect√©")
                else:
                    self.log_error("Type Query manquant")
                
                if schema.get('mutationType', {}).get('name') == 'Mutation':
                    self.log_success("Type Mutation d√©tect√©")
                else:
                    self.log_error("Type Mutation manquant")
                
                # Compter les types
                types = schema.get('types', [])
                type_count = len([t for t in types if not t['name'].startswith('__')])
                
                if type_count > 10:
                    self.log_success(f"Schema riche avec {type_count} types")
                else:
                    self.log_warning(f"Schema simple avec {type_count} types")
                
                return True
            
            else:
                self.log_error("R√©ponse GraphQL invalide")
                return False
        
        except json.JSONDecodeError as e:
            self.log_error("R√©ponse JSON invalide", e)
            return False
        
        except Exception as e:
            self.log_error("Erreur parsing GraphQL", e)
            return False
    
    def test_authentication_flow(self):
        """Test le flux d'authentification complet"""
        
        print("\nüîê TEST FLUX D'AUTHENTIFICATION")
        print("-" * 50)
        
        # Test 1: Cr√©ation d'utilisateur
        self.total_tests += 1
        
        create_user_query = {
            "query": """
            mutation CreateTestUser {
              createUser(
                username: "testuser_validation"
                email: "test.validation@example.com"
                password: "TestPass123!"
                firstName: "Test"
                lastName: "User"
              ) {
                user {
                  id
                  username
                  email
                }
                success
                errors
              }
            }
            """
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=create_user_query)
        
        if error:
            self.log_error("Erreur cr√©ation utilisateur", error)
            return False
        
        try:
            data = response.json()
            
            if 'errors' in data:
                # V√©rifier si c'est une erreur de duplication (acceptable)
                error_messages = [str(err) for err in data['errors']]
                if any('already exists' in msg.lower() or 'duplicate' in msg.lower() for msg in error_messages):
                    self.log_warning("Utilisateur existe d√©j√† (normal)")
                else:
                    self.log_error("Erreurs cr√©ation utilisateur", data['errors'])
                    return False
            
            elif 'data' in data and data['data']['createUser']['success']:
                self.log_success("Utilisateur cr√©√© avec succ√®s")
            
            else:
                self.log_warning("Cr√©ation utilisateur: r√©sultat ambigu")
        
        except Exception as e:
            self.log_error("Erreur parsing cr√©ation utilisateur", e)
            return False
        
        # Test 2: Authentification
        self.total_tests += 1
        
        auth_query = {
            "query": """
            mutation AuthenticateUser {
              tokenAuth(
                email: "test.validation@example.com"
                password: "TestPass123!"
              ) {
                token
                payload
                refreshExpiresIn
              }
            }
            """
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=auth_query)
        
        if error:
            self.log_error("Erreur authentification", error)
            return False
        
        try:
            data = response.json()
            
            if 'errors' in data:
                self.log_error("Erreurs authentification", data['errors'])
                return False
            
            if 'data' in data and data['data']['tokenAuth']['token']:
                token = data['data']['tokenAuth']['token']
                self.session.headers['Authorization'] = f'JWT {token}'
                self.log_success("Authentification r√©ussie")
                return True
            
            else:
                self.log_error("Token JWT non re√ßu")
                return False
        
        except Exception as e:
            self.log_error("Erreur parsing authentification", e)
            return False
    
    def test_crud_operations(self):
        """Test les op√©rations CRUD"""
        
        print("\nüìù TEST OP√âRATIONS CRUD")
        print("-" * 50)
        
        # Test 1: Cr√©ation de post
        self.total_tests += 1
        
        create_post_query = {
            "query": """
            mutation CreateTestPost {
              createPost(
                content: "Post de test pour validation compl√®te #ALX #GraphQL"
                visibility: "public"
              ) {
                post {
                  id
                  content
                  author {
                    username
                  }
                  createdAt
                }
                success
                errors
              }
            }
            """
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=create_post_query)
        
        if error:
            self.log_error("Erreur cr√©ation post", error)
            return False
        
        try:
            data = response.json()
            
            if 'errors' in data:
                self.log_error("Erreurs cr√©ation post", data['errors'])
                return False
            
            if 'data' in data and data['data']['createPost']['success']:
                post_id = data['data']['createPost']['post']['id']
                self.log_success(f"Post cr√©√© avec ID: {post_id}")
                
                # Test 2: Lecture de posts
                self.total_tests += 1
                
                read_posts_query = {
                    "query": """
                    query ReadPosts {
                      allPosts(first: 5) {
                        edges {
                          node {
                            id
                            content
                            author {
                              username
                            }
                            likesCount
                            commentsCount
                          }
                        }
                      }
                    }
                    """
                }
                
                response, error = self.safe_request('POST', self.graphql_url, json=read_posts_query)
                
                if error:
                    self.log_error("Erreur lecture posts", error)
                    return False
                
                read_data = response.json()
                
                if 'errors' in read_data:
                    self.log_error("Erreurs lecture posts", read_data['errors'])
                    return False
                
                posts = read_data['data']['allPosts']['edges']
                if len(posts) > 0:
                    self.log_success(f"Lecture r√©ussie: {len(posts)} posts trouv√©s")
                else:
                    self.log_warning("Aucun post trouv√©")
                
                return True
            
            else:
                self.log_error("Cr√©ation post √©chou√©e")
                return False
        
        except Exception as e:
            self.log_error("Erreur parsing CRUD", e)
            return False
    
    def test_error_handling(self):
        """Test la gestion d'erreurs"""
        
        print("\nüõ°Ô∏è TEST GESTION D'ERREURS")
        print("-" * 50)
        
        # Test 1: Requ√™te invalide
        self.total_tests += 1
        
        invalid_query = {
            "query": "query InvalidQuery { nonExistentField }"
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=invalid_query)
        
        if error:
            self.log_error("Erreur test requ√™te invalide", error)
            return False
        
        try:
            data = response.json()
            
            if 'errors' in data:
                self.log_success("Gestion d'erreur: requ√™te invalide d√©tect√©e")
            else:
                self.log_warning("Requ√™te invalide non d√©tect√©e")
        
        except Exception as e:
            self.log_error("Erreur parsing test erreur", e)
        
        # Test 2: Authentification requise
        self.total_tests += 1
        
        # Supprimer temporairement l'authentification
        auth_header = self.session.headers.pop('Authorization', None)
        
        protected_query = {
            "query": """
            query ProtectedQuery {
              me {
                id
                username
              }
            }
            """
        }
        
        response, error = self.safe_request('POST', self.graphql_url, json=protected_query)
        
        if error:
            self.log_error("Erreur test authentification", error)
        else:
            try:
                data = response.json()
                
                if 'errors' in data:
                    error_messages = [str(err) for err in data['errors']]
                    if any('authentication' in msg.lower() or 'login' in msg.lower() for msg in error_messages):
                        self.log_success("Gestion d'erreur: authentification requise d√©tect√©e")
                    else:
                        self.log_warning("Erreur d'authentification non sp√©cifique")
                else:
                    self.log_warning("Requ√™te prot√©g√©e accessible sans authentification")
            
            except Exception as e:
                self.log_error("Erreur parsing test auth", e)
        
        # Restaurer l'authentification
        if auth_header:
            self.session.headers['Authorization'] = auth_header
        
        return True
    
    def test_api_documentation(self):
        """Test la documentation API"""
        
        print("\nüìö TEST DOCUMENTATION API")
        print("-" * 50)
        
        endpoints_to_test = [
            ('/api/docs/', 'Documentation principale'),
            ('/api/swagger/', 'Interface Swagger'),
            ('/api/health/', 'Health check'),
            ('/api/schema/', 'Sch√©ma API')
        ]
        
        for endpoint, description in endpoints_to_test:
            self.total_tests += 1
            
            response, error = self.safe_request('GET', f"{self.base_url}{endpoint}")
            
            if error:
                self.log_error(f"{description} inaccessible", error)
            elif response.status_code == 200:
                self.log_success(f"{description} accessible")
            else:
                self.log_warning(f"{description} code {response.status_code}")
    
    def generate_final_report(self):
        """G√©n√®re le rapport final"""
        
        print("\n" + "="*60)
        print("üìä RAPPORT FINAL DE VALIDATION")
        print("="*60)
        
        success_rate = (self.passed_tests / self.total_tests * 100) if self.total_tests > 0 else 0
        
        print(f"üìà Tests ex√©cut√©s: {self.total_tests}")
        print(f"‚úÖ Tests r√©ussis: {self.passed_tests}")
        print(f"‚ùå Tests √©chou√©s: {self.failed_tests}")
        print(f"‚ö†Ô∏è Avertissements: {len(self.warnings)}")
        print(f"üéØ Taux de r√©ussite: {success_rate:.1f}%")
        
        if success_rate >= 90:
            print("\nüéä EXCELLENT! Projet pr√™t pour production")
            grade = "A+"
        elif success_rate >= 80:
            print("\nüéâ TR√àS BIEN! Quelques am√©liorations mineures")
            grade = "A"
        elif success_rate >= 70:
            print("\nüëç BIEN! Corrections n√©cessaires")
            grade = "B"
        elif success_rate >= 60:
            print("\n‚ö†Ô∏è PASSABLE! Am√©liorations importantes requises")
            grade = "C"
        else:
            print("\n‚ùå INSUFFISANT! Corrections majeures n√©cessaires")
            grade = "D"
        
        print(f"üìù Note finale: {grade}")
        
        if self.errors:
            print(f"\n‚ùå ERREURS D√âTECT√âES ({len(self.errors)}):")
            for i, error in enumerate(self.errors, 1):
                print(f"   {i}. {error}")
        
        if self.warnings:
            print(f"\n‚ö†Ô∏è AVERTISSEMENTS ({len(self.warnings)}):")
            for i, warning in enumerate(self.warnings, 1):
                print(f"   {i}. {warning}")
        
        # Recommandations
        print(f"\nüí° RECOMMANDATIONS:")
        if success_rate >= 90:
            print("   - Projet excellent, pr√™t pour pr√©sentation ALX")
            print("   - Documentation compl√®te et fonctionnelle")
            print("   - API robuste avec gestion d'erreurs")
        else:
            print("   - Corriger les erreurs identifi√©es")
            print("   - Am√©liorer la gestion d'erreurs")
            print("   - V√©rifier la documentation")
        
        return grade, success_rate
    
    def run_complete_validation(self):
        """Lance la validation compl√®te"""
        
        print("üöÄ D√âMARRAGE VALIDATION COMPL√àTE ALX PROJECT NEXUS")
        print("=" * 60)
        print(f"‚è∞ Heure de d√©but: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        start_time = time.time()
        
        try:
            # Tests s√©quentiels
            if not self.test_server_connectivity():
                print("\n‚ùå ARR√äT: Serveur inaccessible")
                return
            
            if not self.test_graphql_endpoint():
                print("\n‚ùå ARR√äT: GraphQL non fonctionnel")
                return
            
            self.test_authentication_flow()
            self.test_crud_operations()
            self.test_error_handling()
            self.test_api_documentation()
            
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Validation interrompue par l'utilisateur")
        
        except Exception as e:
            print(f"\nüí• Erreur inattendue: {str(e)}")
            print(f"Traceback: {traceback.format_exc()}")
        
        finally:
            end_time = time.time()
            duration = end_time - start_time
            
            print(f"\n‚è∞ Dur√©e totale: {duration:.2f} secondes")
            
            grade, success_rate = self.generate_final_report()
            
            return grade, success_rate

def main():
    """Fonction principale"""
    
    validator = ComprehensiveValidator()
    
    try:
        grade, success_rate = validator.run_complete_validation()
        
        # Code de sortie bas√© sur le taux de r√©ussite
        if success_rate >= 80:
            sys.exit(0)  # Succ√®s
        else:
            sys.exit(1)  # √âchec
    
    except Exception as e:
        print(f"\nüí• Erreur fatale: {str(e)}")
        sys.exit(2)  # Erreur syst√®me

if __name__ == "__main__":
    main()
